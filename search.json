[
  {
    "objectID": "pages/050-remote.html",
    "href": "pages/050-remote.html",
    "title": "Working remotely",
    "section": "",
    "text": "The original super-power of the command line is that it allows us to connect to other machines. While today we have remote-desktops and screen-shares to see and work with other computer’s GUIs, the command line has been doing this since the 1960s!\nIn research, we often work on remote machines (“computing clusters”, “HPC”, “supercomputers”, or even just “servers”), which we need to log in to. Once we are logged in, the terminal will behave as if we are sitting at that machine, which might be on the other side of the world.\n\nUsing ssh\nssh is a program for opening a command line session on a remote computer. The name is short for “secure shell”, because it opens a shell to communicate with a remote machine on the same network, using an encrypted, secure connection.\nssh us01234@bc4login.acrc.bris.ac.uk\nAfter executing something like the above command, you will then be asked to enter your password - it will not display anything or display stars (*) as you type. If the password is correct, you will then see a new prompt, including the name of the machine you are now logged in to, for example:\n[us01234@bc4login3 ~]$\nssh can be used for more than just remote login, it can also execute commands remotely without starting an interactive session.\n\n\nCopying files to and from remote machines using scp\nscp (“secure copy”) is just like cp, except it can copy files and folders to and from another computer. scp is built on top of SSH and provides a secure way to transfer files, ensuring data confidentiality during transit.\nJust like with cp, you can copy the contents of folders with the flag -r.\n# Copy local file to remote host\nscp local_file.txt us01234@bc4login.acrc.bris.ac.uk:/remote/path/\n\n# Copy remote file to local system\nscp us01234@bc4login.acrc.bris.ac.uk:/remote/file.txt /local/path/\n\n# Copy entire directory recursively\nscp -r /local/directory us01234@bc4login.acrc.bris.ac.uk:/remote/path/",
    "crumbs": [
      "Working remotely"
    ]
  },
  {
    "objectID": "pages/023-search.html",
    "href": "pages/023-search.html",
    "title": "Searching",
    "section": "",
    "text": "Finding files\nThe find command searches for files in a directory hierarchy:\n\nFind files by name: find /path/to/search -name \"filename\"\nFind files by type: find /path/to/search -type f\n\nFor example, to find all .txt files in the current directory and subdirectories:\nfind . -name \"*.txt\"\nFind has multiple options that can be very useful to find files with known characteristics other than name, for instance\n\n-size searches by file size\nfind /path -size +10M  # Files larger than 10MB\nfind /path -size -1k   # Files smaller than 1KB\n-mtime searches by modification time\nfind /path -mtime -7  # Files modified in the last 7 days\n\n\n\nLocate command\nThere’s a special tool that allows us to find the path of a command. which finds the location of a command’s executable\nwhich python\n\n\nSearching inside files\nThe command grep (Global Regular Expression Print) allows us to search for patterns inside files:\ngrep \"search_term\" */*.py\n\n\n\n\n\n\nNoteExercise\n\n\n\nSearch in the sandpit folder for any files that contain TP53.",
    "crumbs": [
      "The file system",
      "Searching"
    ]
  },
  {
    "objectID": "pages/022-editing-files.html",
    "href": "pages/022-editing-files.html",
    "title": "Editing files",
    "section": "",
    "text": "There are many text editors that can be used in Linux and Unix systems command line. Two of the most popular ones are nano and vim.\n\nNano\nNano is a simple, user-friendly text editor ideal for quick edits. It’s designed to be easy to use, especially for beginners. It provides an intuitive interface with on-screen shortcuts and basic text editing functions like cut, copy, paste.\nBasic usage:\n\nOpen/create a file: nano filename\nEdit text directly\nSave: Ctrl+O\nExit: Ctrl+X\n\n\n\nVim\nVim (Vi IMproved) is a highly configurable text editor built to enable efficient text editing. It has more powerful features than Nano but has a steeper learning curve. Vim uses a dual mode editing interface (normal and insert) that allow powerful search and replace capabilities.\nBasic usage:\n\nOpen/create a file: vim filename\nEnter insert mode: Press i\nExit insert mode: Press Esc\nSave: :w in normal mode\nExit: :q in normal mode\nSave and exit: :wq in normal mode\n\n\n\n\n\n\n\nNoteExercise\n\n\n\nMake a copy of GDS3716.soft and remove the header of the new file with nano or vim.",
    "crumbs": [
      "The file system",
      "Editing files"
    ]
  },
  {
    "objectID": "pages/070-bioinformatics.html",
    "href": "pages/070-bioinformatics.html",
    "title": "Uses in bioinformatics",
    "section": "",
    "text": "Managing sequence data on the command line\nThis section is aimed at those wanting to use the command line, and perhaps computing clusters, to work with sequence information (that is, genetic, genomic, proteomic and other bioinformatic data). While we recommend using a dedicated programming language for more complex work (this is easier to share, test and replicate), the command line remains a useful environment to acquire and manage data, especially as the first part of an analysis pipeline.\n\n\nSequence archives and repositories\nAll publicly-funded research generating sequence information is obliged to share their data, and this is typically done by placing it with one of the major sequence repositories, for example GenBank at the National Centre for Biotechnology Information (NCBI), or Ensembl at the European Bioinformatics Institute (EBI). Given the scale of these repository, and the varied working practices of many labs across the world, you will sometimes come across poorly-annotated, mislabeled or otherwise inaccurate data. However, just keep this in mind - the vast majority of deposited data is accurate and well-catalogued!\n\n\nExercises\nLet’s work with some real data to answer some real research questions. Firstly, we are going to acquire a small genome to work with. Go to NCBI genbank, and in the search dropdown menu, select Genome. While you are here, notice the other databases that NCBI hosts (each of the items in the dropdown is a database). Many of these are quite niche, but common ones to use are Genome, Gene, Protein and SRA, the latter for raw, unassembled sequence reads.\nWith Genome as your search database, enter “SARS-CoV-2”, and run the search. You should get one result (if you get more, choose the top result). Note the information get here, and follow the link to the reference genome by clicking “Severe acute respiratory syndrome coronavirus 2”, near the top of the page. On this screen, get both the nucleotide and amino acid genome, by clicking the links next to “Download sequences in FASTA format”. Move these two files to a suitable folder to work in, and unzip them. Note their file extensions - faa is “FASTA, amino acids”, fna is “FASTA, nucleotides”, (these are just plain text files, like almost all files we work with on the command line). FASTQ files are the same as FASTA, except with read quality scores, and are typically untrimmed.\nWe’ll start with the nucleotide genome - view the file with less to get a feel of what the data looks like.\n\n\n\n\n\n\nNoteExercise 1\n\n\n\nUse command line tools taught earlier in this course to answer these questions:\n\nHow long is this genome, in kilobases? (Hint: use wc with a flag. Exclude the FASTA header line however you like: you could make a new file and edit it manually, or use pipes with head or tail.)\nWhat is the total nucleotide count each for A, T, C and G in the genome? Is it G-C enriched, or A-T enriched? (Hint: grep with a flag, and wc will help you here.)\nHow many times do we see the start codon (Methionine) in the genome? (Ignore line-breaks for this exercise, and all following questions)\nHow many times does the motif ATGTAG occur in the genome?\nAssume that all protein-coding genes in this genome start with the motifs ATGACC, ATGTTTTAT and ATGCTTTAA (they don’t, this is just an exercise!). How many genes does this covid-19 genome appear to contain?\nThe covid nucleocapsid phosphoprotein starts with the motif ATGTCTGATAAT and ends with AACTCAGGCCTA.\n\nWhat line does the capsid gene start? And end?\nIsolate the capsid gene and make a new file, containing just that gene. Manually trim any non-capsid sequence with a text editor. Make sure it is in FASTA by adding a header line, and give the sequence a name.\n\n\n\n\nNow let’s have a look at the proteome. Again, open it with less and have a look at how it is structured and annotated, noting the differences compared to the nucleotide version of this genome.\n\n\n\n\n\n\nNoteExercise 2\n\n\n\nAnswer these questions about the proteome:\n\nHow many protein-coding genes does SARS-CoV-2 contain?\nWhat is the shortest protein sequence in this genome? (Pick out the short ORF sequences and compare them against each other.)\n\nThe following questions are to introduce you to genomic repositories, and encourage you to explore the archives.\nTake this sequence for the shortest protein (as in cut/copy it). Open NCBI’s BLAST portal and select the protein -&gt; protein option. On the next page, paste your AA sequence into the search box. Choose the program selection (near the bottom) as “Quick BLASTP”. Run the search - this might take a minute or so.\n\nScroll down through the results. From what species of host organism is the closest related gene to your sequence? (ie, not human)\nWhat is the name of the paper in which this sequence was generated?\nWhat are the differences in (amino acid composition) for this sequence?\nIn the codon responsible for this change, which nucleotide position(s) are substituted? (ie, 1st, 2nd or 3rd?)\nWhat is the name of this kind of substitution?",
    "crumbs": [
      "Uses in bioinformatics"
    ]
  },
  {
    "objectID": "pages/030-redirection-pipes.html",
    "href": "pages/030-redirection-pipes.html",
    "title": "Redirection and pipes",
    "section": "",
    "text": "Bash redirection and pipes are powerful features that allow you to control input and output streams, and chain commands together.\n\nRedirection\nRedirection allows you to control where input comes from and where output goes.\nOutput Redirection\n\n&gt;: Redirect stdout to a file (overwrite)\n&gt;&gt;: Redirect stdout to a file (append)\n2&gt;: Redirect stderr to a file\n&&gt;: Redirect both stdout and stderr to a file\n\n# Redirect stdout to a file\necho \"Hello\" &gt; output.txt\n\n# Append stdout to a file\necho \"World\" &gt;&gt; output.txt\n\n# Redirect stderr to a file\nls non_existent_file 2&gt; error.log\n\n# Redirect both stdout and stderr to different files\ncommand &gt; output.txt 2&gt; error.log\n\n# Redirect both stdout and stderr to the same file\ncommand &&gt; output_and_error.log\nInput Redirection\n\n&lt;: Redirect input from a file\n\n# Use file content as input\nsort &lt; unsorted_list.txt\n\n\n\n\n\n\nWarningWarning\n\n\n\nBe careful! Redirects can overwrite the target file.\necho \"Hello, Bash!\" &gt; output.txt\nIf output.txt already existed, it would be permanently overwritten by the above command.\n\n\n\n\nPipes\nPipes (|) allow you to send the output of one command as input to another command.\nSyntax:\ncommand1 | command2 | command3\nExamples:\n# Count number of files in a directory\nls | wc -l\n\n# Find the 5 largest files in a directory\ndu -h | sort -rh | head -5\n\n\nCombining Redirection and Pipes\nYou can combine redirection and pipes for more complex operations:\n# Search for a pattern, sort results, remove duplicates and save to a file\ngrep \"error\" log.txt | sort | uniq &gt; unique_errors.txt\n\n\n\n\n\n\nNoteExercise\n\n\n\n\nIn our sandpit, create a new file from GDS3716.soft that has only the expression values for the first 5 patients and sort the genes (rows) by the expression levels of the last patient included.\nTry running the below command. Can you identify what happened?\n\ncut -f4-6 -d'\\t' GDS3716.soft 2&gt; subset_gds3716.soft",
    "crumbs": [
      "Redirection and pipes"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Welcome to this introduction to the Command Line Interface (CLI)! This course covers a foundation for many computational skills: the UNIX-like (sometimes *nix) command line. This is used by Linux, MacOS, most servers, as well as nearly all HPC and computing clusters.\nHere we will explore the most widely used Linux CLI Bash (Bourne Again Shell) that is default shell in most Linux distributions. Window’s default command line is run by Powershell, which we do not cover in this course. Windows can emulate a UNIX-like terminal, so please continue to learn more.\n\nIntended learning outcomes\nBy the end of this course, you will:\n\nUnderstand the glossary relevant to the command line\nKnow how to create, move and delete files and directories\nBe familiar with command line editors such as nano and vim\nKnow how to search within directories, and within files\nHave the skills to create a simple shell scripts\n\n\n\nStarting a terminal\nWhen you open a terminal, you will be provided with a line for entering commands, starting with a prompt. “Explorer”. Here is what a typical prompt looks like:\n[us01234@laptop: us01234] $\nYour prompt may look a bit different, but here is what it means:\n[ your_name @ host_name : current_folder ] $\nFirst is your own user name. On UoB computers, it might be a code like in your email address, such as us01234. After the @ comes the computer’s name (or hostname). This could be something like myMacBook or ubuntu, for example. Note that this is the name of the computer that you are logged in, your computer or the name of a remote machine when using HPC. Finally, we have the folder you are working in, after the :. Yours might say ~ (“tilde”) - find out what that means in the next sections.\nThe $ (or you might have a %) symbol means the terminal is waiting for a command. Sometimes you will see commands on the internet which include the $ symbol at the start of the command - you don’t need to include this as part of the command, say if you cut and paste!\n\n\n          _nnnn_                      \n         dGGGGMMb     ,\"\"\"\"\"\"\"\"\"\"\"\"\"\".\n        @p~qp~~qMb    | Linux Rules! |\n        M|@||@) M|   _;..............'\n        @,----.JM| -'\n       JS^\\__/  qKL\n      dZP        qKRb\n     dZP          qKKb\n    fZP            SMMb\n    HZM            MMMM\n    FqM            MMMM\n  __| \".        |\\dS\"qML\n  |    `.       | `' \\Zq\n _)      \\.___.,|     .'\n \\____   )MMMMMM|   .'\n      `-'       `--' hjm",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "pages/040-scripting.html",
    "href": "pages/040-scripting.html",
    "title": "Shell scripts",
    "section": "",
    "text": "So far, we have been running things directly on the command line, “interactively”. However, you might want to keep your commands in a file, and be able to run, share, modify, or use files as templates. This is the gateway to coding and is great practice for developing your reproducible work.\nA script is a file of instructions that can be directly read and run by a program. In our case, we are going to make a script in shell language.\nLet’s create a very simple script. Open nano creating a file called first_script.sh and include the lines\n#!/bin/bash\n\nls -l *soft\necho \"That is all of the files with \\\"soft\\\" in that I could find here.\"\nIt is a good practice to always start your scripts with a shebang line like #!/bin/bash, that tells the system to run the correct shell for the script.\nShell scripts need to have execution permission, so it is important to remember to make your scripts executable with chmod +x script.sh. Once done it, we can run our first script with\n./first_script.sh\n\nVariables and structures\nScripts can also have variables, conditional structures and loops. While a deep dive into these concepts is beyond the scope of an introductory course, it is worth mentioning them to understand all the basic capabilities of shell scripting.\nUse descriptive variable names:\nuser_name=\"John\"\necho \"Hello, ${user_name}!\"\nMake decisions using if-then-else statements:\nif [[ \"$1\" == \"help\" ]]; then\n  echo \"Usage: script.sh [option]\"\nelif [[ \"$1\" == \"version\" ]]; then\n  echo \"Version 1.0\"\nelse\n  echo \"Unknown option\"\nfi\nAllow repetition of commands for a specified number of iterations or over a list of items:\nfor file in *.txt; do\n  echo \"Processing ${file}\"\ndone\n\n\n\n\n\n\nNoteExercise\n\n\n\nCreate a script that for all the .soft files in the current directory, prints the number of lines of each file.",
    "crumbs": [
      "Shell scripts"
    ]
  },
  {
    "objectID": "pages/010-cli.html",
    "href": "pages/010-cli.html",
    "title": "The Unix Command Line",
    "section": "",
    "text": "Unix systems are powerful, multi-user operating systems that have had a profound impact on modern computing since their development in the 1970s at Bell Labs. Unix, Linux, BSD, and macOS are all related operating systems that share a common heritage and many similar features.\nUnix introduced several key concepts such a command-line interface (shell) and the core philosophy that “everything is a file”. This may sound strange, but it basically means that the system handles input/output to and from various resources as streams of bytes exposed through the filesystem. For instance, Unix defines three Standard Streams:\n\nstdin (0): Standard input, by default the keyboard input\nstdout (1): Standard output, by defult your terminal output on the screen\nstderr (2): Standard error, by defult also your terminal output, but on a separate different stream\n\nThis approach provides a consistent interface for interacting with various system resources and the flexibility to use and combine the same commands and tools across different types of files.\nPrint to Terminal\nThe command echo prints text to the terminal (by default stdout), useful in scripts and for displaying variable values and messages.\necho \"Hello, Shell!\"\nWe will see the concept of redirections in the next sections, but given that everything is a file, we could redirect our output in the terminal to a file\necho \"Hello, Shell!\" &gt; hello.txt\n\n\n\n\n\n\nTipCommand line basics\n\n\n\n\nThe command line is case-sensitive. The letter H is entirely different from h, for example! So if you are having issues, always check your capitalisation is correct.\nYou can select, cut etc with the mouse cursor, but you cannot move the position of your typing cursor with the mouse! You can only do that with the arrow keys. This is because a remote machine can only understand plain text, not communications from your mouse.\nYou can use tab to auto-complete: it will save you lots of time and typos.\nYou can scroll back through your previous commands with the up arrow (and down arrow) - another big time-saver.\nIf it looks like the terminal is stuck, or you want to cancel a command, it is Ctrl-c.\nTo exit a terminal session, type exit.\n\n\n\n\nThe grammar of the command line\nBash grammar refers to the syntax and structure of commands and scripts in the Bash shell. The basic command syntax will look like\ncommand [options] [arguments]\nwhere options is commonly set of flags like -a, and arguments are other parameters and file names. For example:\nls -l /home/user\n\n\nGetting help on the command line\nMuch of your knowledge about commands will of course come from the Internet, but you can also look up help and manuals on the command line itself. They are called man pages, short for “manual”. When you run this command, for example\nman ls\nYou will get description and instructions on what the command does, how to use it, and what flags it can take. Some man pages are better than others, but it is good to get familiar with them, and get a feel for how documentation is structured. When you search for a command on the internet, often the best results are just the man pages, presented in a webpage, which might be easier to understand and search through.",
    "crumbs": [
      "The Unix Command Line"
    ]
  },
  {
    "objectID": "pages/020-file-system.html",
    "href": "pages/020-file-system.html",
    "title": "The file system",
    "section": "",
    "text": "The file system provides a structured way to name and organize files, typically using a hierarchical directory structure. Below there are some of the basic commands to move around.\n\nPrint Working Directory\nThe pwd command prints the current working directory path.\npwd\n/users/home/us01234\n\n\nChange Directory\nUse cd to navigate between directories:\n\ncd directory_name: Move into a specific directory\ncd ..: Move up one directory level\ncd ~: Go to home directory\n\n\n\n\n\n\n\nTipLocation abbreviations\n\n\n\n\n~ tilde, your home folder (also $HOME)\n. dot, your current working folder\n.. dot dot, one folder up or back from here\n- dash, the folder you were most recently in\n/ root, the folder containing the whole file system\nif we type cd alone it will always take you back to your $HOME\n\n\n\n\n\nList Directory Contents\nThe ls command lists files and directories in the current location. Common options include:\n\nls -a: List all files, including hidden ones\nls -l: Long listing with details like permissions and timestamps\n\nus01234@myMacBook course-cli % ls                                     \nREADME.md       answers         data            requirements.txt\n_extensions     appendix        index.qmd       style.scss\n_quarto.yml     assets          pages\nus01234@myMacBook course-cli % ls -a                                    \n.               .gitignore      appendix        requirements.txt\n..              README.md       assets          style.scss\n.DS_Store       _extensions     data\n.git            _quarto.yml     index.qmd\n.github         answers         pages\nYou can also use list filtering for specific file names or patterns.\nus01234@myMacBook course-cli % ls -la *.txt\n-rw-r--r--@ 1 gx18744  staff  15 26 Sep 02:06 requirements.txt                                   \n\n\n\n\n\n\nTipSpecial characters\n\n\n\n\n* wildcard (any characters): ls *.txt\n? wildcard (single character): ls file?.txt\n[] character set wildcard: ls file[123].txt\n{} brace expansion: echo {1..5}",
    "crumbs": [
      "The file system"
    ]
  },
  {
    "objectID": "pages/024-permissions.html",
    "href": "pages/024-permissions.html",
    "title": "Permissions",
    "section": "",
    "text": "Unix file permissions are a fundamental aspect of system security and access control. While this course does not delve into detailed system administration, understanding the basics of file permissions is crucial for effective Unix system usage.\n\nPermission Structure\nThe ls -la command is used to list files and directories with detailed information, including file permissions that are represented by 10-character strings at the begining of each line.\nus01234@myMacBook course-cli % ls -la                                      \ntotal 72\ndrwxr-xr-x@ 17 us01234  staff   544 26 Sep 02:35 .\ndrwxr-xr-x  10 us01234  staff   320  8 Oct 09:32 ..\n-rw-r--r--@  1 us01234  staff  8196  3 Oct 23:58 .DS_Store\ndrwxr-xr-x@ 15 us01234  staff   480  3 Oct 23:58 .git\ndrwxr-xr-x@  3 us01234  staff    96 26 Sep 02:06 .github\n-rw-r--r--@  1 us01234  staff    32 26 Sep 02:06 .gitignore\n-rw-r--r--@  1 us01234  staff   428 26 Sep 02:06 README.md\ndrwxr-xr-x@  3 us01234  staff    96 26 Sep 02:06 _extensions\n-rw-r--r--@  1 us01234  staff  1458 26 Sep 02:06 _quarto.yml\ndrwxr-xr-x@ 19 us01234  staff   608 26 Sep 02:36 answers\ndrwxr-xr-x@ 11 us01234  staff   352 26 Sep 02:06 appendix\ndrwxr-xr-x@ 13 us01234  staff   416 26 Sep 02:06 assets\ndrwxr-xr-x@  5 us01234  staff   160 26 Sep 02:06 data\n-rw-r--r--@  1 us01234  staff  3357 26 Sep 02:06 index.qmd\ndrwxr-xr-x@ 17 us01234  staff   544 26 Sep 02:06 pages\n-rw-r--r--@  1 us01234  staff    15 26 Sep 02:06 requirements.txt\n-rw-r--r--@  1 us01234  staff   645 26 Sep 02:06 style.scss\nThe first character indicates the file type:\n\n- regular file\nd directory\nl symbolic link\n\nThe next nine characters represent permissions for three categories of users:\n\nOwner (user)\nGroup\nOthers (everyone else)\n\nFor each category, there are three types of permissions:\n\nr read permission\nw write permission\nx execute permission for files, or access permission for directories\n\nPermission representation\nPermissions can also be written numerically as the sum of a 3-bit binary number:\n\nr (read) = 4 (binary 100)\nw (write) = 2 (binary 010)\nx (execute) = 1 (binary 001)\n\nSome common permission sets are:\n\n644 (-rw-r–r–): Standard for regular files\n755 (-rwxr-xr-x): Standard for directories and executable files\n600 (-rw——-): Private file, readable and writable only by owner\n\n\n\nChanging Permissions\nThe chmod command is used to modify permissions\nchmod 644 file.txt\nchmod u+x script.sh\nOnly the file owner or an administrator can change file permissions.",
    "crumbs": [
      "The file system",
      "Permissions"
    ]
  },
  {
    "objectID": "pages/021-files-directories.html",
    "href": "pages/021-files-directories.html",
    "title": "Managing files and directories",
    "section": "",
    "text": "Creating new files and directories\nMake a directory\nYou can create new directories with the mkdir command:\nmkdir my_new_directory\nCreate an empty file\nThe touch command creates a new empty file or updates timestamps (modification time) of existing files:\ntouch new_file.txt\n\n\nCopying and moving\n\n\n\n\n\n\nWarningWarning\n\n\n\nThe commands cp, mv and rm need to be used with care, all have the potential to cause permanent data loss!\nIf, for example, a file data.txt already exists, the command\ncp new_data.txt data.txt\nwould overwrite data.txt with the contents of new_data.txt permanently deleting the contents of data.txt! Likewise, rm doesn’t have a recycle bin, undo or any other safety-nets.\n\n\nCopy\nWe can copy files or directories with cp. Note that to copy (non-empty) directories you will need to use the flag -r.\ncp file1.txt file1_backup.txt\ncp -r sourcedir/ destdir/\nMove/Rename\nMove or rename files and directories is done with mv.\nmv old_name.txt new_name.txt\nmv file.txt /path/to/new/location/\n\n\nDeleting files and directories\nIn Unix, the deletion of files and directories is done with the command rm. If a folder is not empty, we need to delete all the contents before or use the flag -r.\nrm file.txt\nrm -r directory/\n\n\nViewing File Contents\nConcatenate and Display\nThe cat command displays file contents in the terminal:\ncat my_file.txt\nPaginated File Viewing\nless allows scrolling through large files[1]:\nless large_file.log\nView first or last lines\nhead ad tail commands are useful for quickly inspecting the contents of large files, monitoring log files, or extracting specific portions of text data.\nThe head command displays the first part of files.\n# Display first 10 lines of a file\nhead file.txt\n\n# Display first 15 lines of multiple files\nhead -n 15 file1.txt file2.txt\nThe tail command displays the last part of files.\n# Display last 10 lines of a file\ntail file.txt\n\n# Display last 20 lines of a file\ntail -n 20 file.txt\n\n# Display last 5 lines of multiple files\ntail -n 5 file1.txt file2.txt\n\n\nOther commands\nThere are many other commands useful for processing and manipulating text files in Bash.\nWord Count\nThe wc command is used to count lines -l, words -w, and characters -m in files.\nwc -l file.txt  # Count lines in file.txt\nSort\nThe sort command is used to sort lines of text files.\nsort file.txt  \n\nsort -n numbers.txt  # Sort numbers numerically\nCut\nThe cut command is used to extract sections from each line of files. Some of the common options are: -c selects specific characters, -f selects specific fields, -d specifies the delimiter.\ncut -f1,3 -d',' data.csv  # Extract 1st and 3rd comma-separated fields\n\n\n\n\n\n\nNoteExercise\n\n\n\n\nCreate a folder called sandpit and enter it.\nDownload and unzip the below dataset with gene expression data of 42 ER- and ER+ breast cancer patients.\nwget https://ftp.ncbi.nlm.nih.gov/geo/datasets/GDS3nnn/GDS3716/soft/GDS3716.soft.gz\ngunzip GDS3716.soft.gz\nInspect the file format of the uncompressed file.\nHow long is the file?\nAre you able identify where the header finishes and starts the data?\nWhat do you think the below command does? You can try executing it.\ncut -f2,4-6 -d$'\\t' GDS3716.soft             \nMake a copy of it to keep our raw data safe.",
    "crumbs": [
      "The file system",
      "Managing files and directories"
    ]
  },
  {
    "objectID": "pages/990-contributors.html",
    "href": "pages/990-contributors.html",
    "title": "Contributors",
    "section": "",
    "text": "Parts of this course are based on the materials written by Al Tanner, see https://altanner.github.io/intro-to-command-line/.\nThe course has been developed by the Jean Golding Institute.\n\nPau Erola",
    "crumbs": [
      "Contributors"
    ]
  }
]